// SPDX-FileCopyrightText: 2025 The SayWare development team
//
// SPDX-License-Identifier: GPL-3.0-or-later

use cfonts::{Fonts, Options, render};
use std::ptr;
use windows::{
    Win32::{
        Networking::WinHttp::{
            WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY, WINHTTP_FLAG_ASYNC, WINHTTP_FLAG_REFRESH,
            WINHTTP_FLAG_SECURE, WinHttpCloseHandle, WinHttpConnect, WinHttpOpen,
            WinHttpOpenRequest, WinHttpQueryDataAvailable, WinHttpReadDataEx,
            WinHttpReceiveResponse, WinHttpSendRequest,
        },
        System::Console::{GetStdHandle, STD_OUTPUT_HANDLE, WriteConsoleW},
    },
    core::{Owned, PCWSTR, PWSTR, w},
};

include!(concat!(env!("OUT_DIR"), "/configuration.rs"));

fn main() {
    let session = unsafe {
        WinHttpOpen(
            PWSTR::null(),
            WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY,
            PWSTR::null(),
            PWSTR::null(),
            WINHTTP_FLAG_ASYNC,
        )
    };

    if unsafe { session.as_ref() }.is_none() {
        return;
    }

    let connection = unsafe { WinHttpConnect(session, SERVER_HOSTNAME, SERVER_PORT, 0) };

    if unsafe { connection.as_ref() }.is_none() {
        let _ = unsafe { WinHttpCloseHandle(session) };

        return;
    }

    let request = unsafe {
        WinHttpOpenRequest(
            connection,
            PWSTR::null(),
            PCWSTR::from_raw(
                format!("{}/", SERVER_URL_PREFIX)
                    .encode_utf16()
                    .collect::<Vec<_>>()
                    .as_ptr(),
            ),
            PCWSTR::null(),
            PCWSTR::null(),
            &PCWSTR::null(),
            WINHTTP_FLAG_REFRESH | WINHTTP_FLAG_SECURE,
        )
    };

    if unsafe { request.as_ref() }.is_none() {
        let _ = unsafe { WinHttpCloseHandle(connection) };
        let _ = unsafe { WinHttpCloseHandle(session) };

        return;
    }

    if unsafe { WinHttpSendRequest(request, None, None, 0, 0, 0) }.is_err() {
        let _ = unsafe { WinHttpCloseHandle(request) };
        let _ = unsafe { WinHttpCloseHandle(connection) };
        let _ = unsafe { WinHttpCloseHandle(session) };

        return;
    };

    if unsafe { WinHttpReceiveResponse(request, ptr::null_mut()) }.is_err() {
        let _ = unsafe { WinHttpCloseHandle(request) };
        let _ = unsafe { WinHttpCloseHandle(connection) };
        let _ = unsafe { WinHttpCloseHandle(session) };

        return;
    }

    let available_bytes: u32 = 0;

    if unsafe { WinHttpQueryDataAvailable(request, &available_bytes as *const _ as *mut _) }
        .is_err()
    {
        let _ = unsafe { WinHttpCloseHandle(request) };
        let _ = unsafe { WinHttpCloseHandle(connection) };
        let _ = unsafe { WinHttpCloseHandle(session) };
    }

    let mut sentence_bytes = vec![0u8; available_bytes as usize];

    let status_code = unsafe {
        WinHttpReadDataEx(
            request,
            sentence_bytes.as_mut_ptr() as *mut _,
            available_bytes,
            ptr::null_mut(),
            0, // I don't find "READ_DATA_EX_FLAG_FILL_BUFFER"
            0,
            None,
        )
    };

    let _ = unsafe { WinHttpCloseHandle(request) };
    let _ = unsafe { WinHttpCloseHandle(connection) };
    let _ = unsafe { WinHttpCloseHandle(session) };

    if status_code != 0 {
        return;
    }

    let sentence = {
        let Ok(sentence) = String::from_utf8(sentence_bytes) else {
            return;
        };

        render(Options {
            text: sentence,
            font: Fonts::FontTiny,
            ..Options::default()
        })
        .text
        .encode_utf16()
        .collect::<Vec<_>>()
    };

    let standard_output = {
        let Ok(standard_output) = (unsafe { GetStdHandle(STD_OUTPUT_HANDLE) }) else {
            return;
        };

        unsafe { Owned::new(standard_output) }
    };

    let _ = unsafe { WriteConsoleW(*standard_output, sentence.as_slice(), None, None) };
}
